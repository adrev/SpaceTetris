<!DOCTYPE html>
<html>
<head>
    <title>SpaceTris</title>
    <style>
        canvas {
            border: 1px solid white;
            background: black;
        }
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #111;
            gap: 20px;
            overflow: hidden;
        }
        #restartBtn {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #resta  rtBtn:hover {
            background: #666;
        }
        #scoreDisplay {
            color: white;
            font-size: 20px;
            font-family: Arial, sans-serif;
        }
        #instructions {
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            max-width: 400px;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }
        #instructions h3 {
            margin: 0 0 10px 0;
            font-size: 20px;
            color: #00FFFF;
        }
        #instructions ul {
            list-style: none;
            padding: 0;
            margin: 0;
            text-align: left;
        }
        #instructions li {
            margin-bottom: 8px;
            line-height: 1.4;
        }
        #instructions li strong {
            color: #FFFF00;
        }
        #mobileControls {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            border-top: 1px solid #333;
        }
        .directional-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .directional-buttons button {
            padding: 10px;
            font-size: 20px;
            cursor: pointer;
            background: #333;
            color: white;
            border: none;
            border-radius: 5px;
        }

        /* New CSS for mobile controls */
        #mobileControls {
            display: none; /* Hidden on larger screens */
        }
        @media (max-width: 600px) {
            #mobileControls {
                display: block;
                text-align: center;
                margin-top: 20px;
            }
            #mobileControls .directional-buttons button {
                font-size: 24px;
                padding: 10px;
                margin: 5px;
                background: #444;
                color: white;
                border: none;
                border-radius: 5px;
            }
            #mobileControls .directional-buttons button:hover {
                background: #666;
            }
        }

        /* New CSS for mobile controls */
        #joystickContainer {
            position: fixed;
            bottom: 30px;
            left: 30px;
        }
        #joystickZone {
            width: 240px;
            height: 240px;
            border: 8px solid #FFF;
            border-radius: 50%;
            touch-action: none;
        }
        #mobileFireBtn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #FF0000;
            color: white;
            font-size: 48px;
            border: none;
        }

        /* User Profile / Nickname Input styling */
        #userProfile {
            margin-top: 10px;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #nicknameInput {
            padding: 5px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        /* Game Over Overlay styling */
        #gameOverOverlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none; /* hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        #gameOverOverlay #userProfile {
            background: #222;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }

        /* Leaderboard styling */
        #publicHighscoreDisplay {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            padding: 10px;
            border-radius: 8px;
            position: fixed;
            top: 50%;
            right: 10px;
            transform: translateY(-50%);
            width: 250px;     /* Reduced width */
            max-height: 70vh;
            overflow-y: auto;
            z-index: 1000;
        }

        #publicHighscoreDisplay h3 {
            font-size: 20px;
            color: #00FFFF;
            margin-top: 0;
        }

        #publicHighscoreDisplay ol {
            margin: 0;
            padding-left: 20px;
        }

        #publicHighscoreDisplay li {
            margin: 5px 0;
        }

        /* Styling for the submit score button to match overall design */
        #submitScoreBtn {
            background: #444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }

        #submitScoreBtn:hover {
            background: #666;
        }

        /* Improve overlay text styling */
        #gameOverOverlay p {
            font-family: Arial, sans-serif;
            font-size: 18px;
            margin-bottom: 10px;
            color: white;
        }

        /* On mobile screens, let the leaderboard be in the normal document flow */
        @media (max-width: 600px) {
            #publicHighscoreDisplay {
                position: static;
                width: 80%;                /* Reduced width */
                max-height: none;
                margin-top: 20px;
                margin-bottom: 20px;
                transform: none;
            }
        }
    </style>
    <!-- Include NippleJS for the on-screen joystick -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.7.3/nipplejs.min.js"></script>
</head>
<body>
    <canvas id="gameCanvas" width="400" height="600"></canvas>
    <div id="scoreDisplay">Score: 0 | High Score: 0</div>
    <!-- Game Over Overlay (hidden at first) -->
    <div id="gameOverOverlay" style="display: none;">
       <div id="userProfile">
           <p>Game Over! Enter your nickname to submit your score:</p>
           <input type="text" id="nicknameInput" placeholder="Enter your nickname" />
           <button id="submitScoreBtn">Submit Score</button>
       </div>
    </div>
    <button id="restartBtn">Restart Game</button>
    <div id="congratsMessage" style="color: yellow; font-family: Arial, sans-serif; font-size: 18px; text-align: center;"></div>
    <div id="instructions">
        <h3>How to Play SpaceTris</h3>
        <ul>
            <li><strong>Controls:</strong> Move your green spaceship with <em>W/A/S/D</em> or <em>Arrow keys</em>.</li>
            <li><strong>Shoot:</strong> Press <em>Space</em> to fire bullets at red invaders (10 points) and falling Tetris blocks (5 points).</li>
            <li><strong>Objective:</strong> Avoid collisions with invaders and blocks. Clear blocks to keep them from stacking to the top!</li>
            <li><strong>Game Over:</strong> Ends if you hit an enemy/block or if blocks overflow the screen.</li>
            <li><strong>Challenge:</strong> Blocks fall faster as your score increasesâ€”stay sharp!</li>
        </ul>
    </div>
    <!-- Leaderboard: Top 100 scores -->
    <div id="publicHighscoreDisplay"></div>
    <!-- 8-bit space inspired background music -->
    <audio id="bgMusic">
       <source id="bgMusicSource" src="SpaceTris_Soundtrack/01 - Main Theme - Galactic Inferno.mp3" type="audio/mpeg">
       Your browser does not support the audio element.
    </audio>

    <!-- New Mobile Controls -->
    <div id="joystickContainer">
        <div id="joystickZone"></div>
    </div>
    <button id="mobileFireBtn">Fire</button>

    <!-- Settings Button -->
    <button id="settingsBtn" style="position: fixed; top: 10px; left: 10px; background: #444; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; z-index: 1000;">Settings</button>

    <!-- Settings Overlay -->
    <div id="settingsOverlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 15000;">
        <div style="background: rgba(0,0,0,0.7); padding: 15px; border-radius: 8px; text-align: center; color: white; max-width: 400px; margin: 0 20px;">
            <h2 style="color: #00FFFF; margin-top: 0;">Settings</h2>
            <!-- Display player name -->
            <p id="playerNameDisplay" style="font-size: 16px; margin: 5px 0;">Player: Anonymous</p>
            <label style="font-size: 16px;">
                <input type="checkbox" id="muteMusicCheckbox"> Mute Music
            </label>
            <br><br>
            <label style="font-size: 16px;">
                Keyboard Sensitivity:
                <input type="range" id="keyboardSensitivitySlider" min="5" max="20" value="10" style="vertical-align: middle;">
                <span id="keyboardSensitivityValue" style="vertical-align: middle;">10</span>
            </label>
            <br><br>
            <button id="closeSettingsBtn" style="padding: 8px 12px; border: none; border-radius: 5px; background: #444; color: white; cursor: pointer;">Close</button>
        </div>
    </div>

    <script type="module">
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const restartBtn = document.getElementById('restartBtn');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const bgMusic = document.getElementById('bgMusic');
        let isMuted = false;
        let gamePaused = false;
        let gameLoopRequestID;  // To store our requestAnimationFrame ID

        // Grid settings
        const GRID_SIZE = 20;
        const GRID_WIDTH = canvas.width / GRID_SIZE;
        const GRID_HEIGHT = canvas.height / GRID_SIZE;

        // Game objects
        let player = {
            x: 9 * GRID_SIZE,
            y: 27 * GRID_SIZE,
            width: 2 * GRID_SIZE,
            height: GRID_SIZE,
            moveCooldown: 0,
            moveDelay: 10
        };

        let invaders = [];
        let bullets = [];
        let blocks = [];
        let alienAnims = [];
        let score = 0;
        let highScore = localStorage.getItem('highScore') ? parseInt(localStorage.getItem('highScore')) : 0;
        let gameOver = false;
        let timeElapsed = 0;
        let blockSpawnRate = 0.01;
        let baseBlockSpeed = 1;

        // Tetris shapes with specific colors
        const shapes = [
            { shape: [[1,1,1,1]], color: '#00FFFF' },
            { shape: [[1,1],[1,1]], color: '#FFFF00' },
            { shape: [[1,1,1],[0,1,0]], color: '#FF00FF' }
        ];

        // Game controls
        let leftPressed = false;
        let rightPressed = false;
        let upPressed = false;
        let downPressed = false;
        let shootRequested = false;
        let cheatMode = false;
        let spaceDown = false;

        // Clear all control flags if the window loses focus.
        window.addEventListener('blur', () => {
            leftPressed = false;
            rightPressed = false;
            upPressed = false;
            downPressed = false;
            shootRequested = false;
            spaceDown = false;
            cheatMode = false;
        });

        // Also reset flags when the page becomes hidden (e.g. user switches tab)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                leftPressed = false;
                rightPressed = false;
                upPressed = false;
                downPressed = false;
                shootRequested = false;
                spaceDown = false;
                cheatMode = false;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = true;
            if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = true;
            if (e.key === 'ArrowUp' || e.key === 'w') upPressed = true;
            if (e.key === 'ArrowDown' || e.key === 's') downPressed = true;
            if (e.key === ' ' || e.key === 'Spacebar') {
                e.preventDefault();
                // Only trigger a new shot if space is not already held down
                if (!spaceDown) {
                    if (e.shiftKey) {
                        cheatMode = true;
                    } else {
                        shootRequested = true;
                    }
                    spaceDown = true;
                }
            }
            if (e.key === "Escape") {
                let settingsOverlay = document.getElementById('settingsOverlay');
                if (settingsOverlay.style.display === "flex") {
                    // If open, close settings (simulate clicking close)
                    document.getElementById('closeSettingsBtn').click();
                } else {
                    // Otherwise, open settings
                    document.getElementById('settingsBtn').click();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === ' ' || e.key === 'Spacebar') {
                spaceDown = false;
            }
            if (e.key === 'Shift') {
                cheatMode = false;
            }
            if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = false;
            if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = false;
            if (e.key === 'ArrowUp' || e.key === 'w') upPressed = false;
            if (e.key === 'ArrowDown' || e.key === 's') downPressed = false;
        });

        /* New: Mobile joystick controls using NippleJS */
        const joystickContainer = document.getElementById('joystickContainer');
        const joystickZone = document.getElementById('joystickZone');
        const mobileFireBtn = document.getElementById('mobileFireBtn');

        if (joystickZone) {
            const joystickManager = nipplejs.create({
               zone: joystickZone,
               mode: 'static',
               position: { left: '50%', top: '50%' },
               color: 'white'
            });
            joystickManager.on('move', function (evt, data) {
                // Set a threshold to determine when movement is intentional.
                const distance = data.distance;
                const angle = data.angle.degree;
                if (distance > 10) { // you can adjust this threshold
                    // Clear all direction flags before setting one:
                    leftPressed = rightPressed = upPressed = downPressed = false;
                    if (angle >= 45 && angle <= 135) {
                        upPressed = true;
                    } else if (angle >= 225 && angle <= 315) {
                        downPressed = true;
                    } else if (angle < 45 || angle > 315) {
                        rightPressed = true;
                    } else if (angle >= 135 && angle <= 225) {
                        leftPressed = true;
                    }
                }
            });
            joystickManager.on('end', function () {
                leftPressed = rightPressed = upPressed = downPressed = false;
            });
        }

        if (mobileFireBtn) {
            mobileFireBtn.addEventListener('touchstart', (e) => { 
                shootRequested = true; 
                e.preventDefault(); 
            });
            mobileFireBtn.addEventListener('touchend', (e) => { 
                shootRequested = false;
                e.preventDefault(); 
            });
        }

        function startMusic() {
             if (bgMusic && bgMusic.paused) {
                 bgMusic.play()
                     .then(() => {
                         console.log("Background music started successfully, current track:", bgMusic.currentSrc);
                         // Show message for initial track (folderTracks[0])
                         displayNowPlaying(folderTracks[0]);
                     })
                     .catch(err => {
                         console.error("Error starting background music:", err);
                     });
             } else {
                 console.log("startMusic() called but bgMusic is not paused or not available.");
             }
        }

        // Listen for touch, click, and keyboard events to start background music
        document.body.addEventListener('click', startMusic, { once: true });
        document.body.addEventListener('keydown', startMusic, { once: true });
        document.body.addEventListener('mousedown', startMusic, { once: true });
        document.body.addEventListener('touchstart', startMusic, { once: true });

        // Setup Background Music Track Cycling
        const folderTracks = [
            "SpaceTris_Soundtrack/01 - Main Theme - Galactic Inferno.mp3",
            "SpaceTris_Soundtrack/02 - Cosmic Cascade.mp3",
            "SpaceTris_Soundtrack/03 - Pixel Invasion.mp3",
            "SpaceTris_Soundtrack/04 - Neon Blocks.mp3",
            "SpaceTris_Soundtrack/05 - Galactic Grid.mp3",
            "SpaceTris_Soundtrack/06 - Retro Orbit.mp3",
            "SpaceTris_Soundtrack/07 - Tetrimino Twilight.mp3",
            "SpaceTris_Soundtrack/08 - Alien Ascension.mp3",
            "SpaceTris_Soundtrack/09 - Arcade Anomaly.mp3",
            "SpaceTris_Soundtrack/10 - Synth Spacefall.mp3",
            "SpaceTris_Soundtrack/11 - Digital Drift.mp3"
        ];
        const finalLoopTrack = "background-music.mp3"; // The file to loop after track 11
        let currentTrackIndex = 0;

        bgMusic.addEventListener('ended', () => {
            if (currentTrackIndex < folderTracks.length - 1) {
                currentTrackIndex++;
                let newTrack = folderTracks[currentTrackIndex];
                document.getElementById('bgMusicSource').src = newTrack;
                bgMusic.loop = false; // Ensure looping is off for these tracks
                bgMusic.load();
                bgMusic.play();
                displayNowPlaying(newTrack);
            } else {
                document.getElementById('bgMusicSource').src = finalLoopTrack;
                bgMusic.loop = true;
                bgMusic.load();
                bgMusic.play();
                displayNowPlaying(finalLoopTrack);
            }
        });

        // Log errors if the background music fails to load
        bgMusic.addEventListener('error', (e) => {
            console.error("Error loading background music:", e, bgMusic.error);
        });

        // Spawn invaders
        function spawnInvader() {
            const invader = {
                x: Math.floor(Math.random() * (GRID_WIDTH - 2)) * GRID_SIZE,
                y: 0,
                width: 2 * GRID_SIZE,
                height: GRID_SIZE,
                speed: 1
            };
            invaders.push(invader);
        }

        // Spawn falling Tetris block
        function spawnBlock() {
            const template = shapes[Math.floor(Math.random() * shapes.length)];
            const blockSpeed = baseBlockSpeed + (score / 100);
            const block = {
                x: Math.floor(Math.random() * (GRID_WIDTH - template.shape[0].length)) * GRID_SIZE,
                y: 0,
                shape: template.shape,
                color: template.color,
                width: template.shape[0].length * GRID_SIZE,
                height: template.shape.length * GRID_SIZE,
                speed: Math.min(blockSpeed, 5),
                stopped: false
            };
            blocks.push(block);
        }

        // Shoot bullet
        function shoot() {
            let beamCount = 1;
            let bulletsPerBeam = 1;

            // Determine the number of beams and bullets per beam based on score thresholds:
            if (score >= 1000) {
                beamCount = 5;
                bulletsPerBeam = 16;
            } else if (score >= 750) {
                beamCount = 4;
                bulletsPerBeam = 8;
            } else if (score >= 500) {
                beamCount = 3;
                bulletsPerBeam = 4;
            } else if (score >= 250) {
                beamCount = 2;
                bulletsPerBeam = 2;
            }

            // Calculate base offsets for each beam so they fan out horizontally
            let beamOffsets = [];
            if (beamCount === 1) {
                beamOffsets.push(0);
            } else if (beamCount === 2) {
                beamOffsets.push(-5, 5);
            } else if (beamCount === 3) {
                beamOffsets.push(-10, 0, 10);
            } else if (beamCount === 4) {
                beamOffsets.push(-15, -5, 5, 15);
            } else if (beamCount === 5) {
                beamOffsets.push(-20, -10, 0, 10, 20);
            }

            // For each beam, fire the specified number of bullets with additional inner spread.
            for (let i = 0; i < beamCount; i++) {
                for (let j = 0; j < bulletsPerBeam; j++) {
                    // Compute an inner offset: for multiple bullets in the same beam, space them out evenly.
                    let innerOffset = (bulletsPerBeam > 1 ? (j - (bulletsPerBeam - 1) / 2) * 2 : 0);
                    let totalOffset = beamOffsets[i] + innerOffset;

                    const bullet = {
                        x: player.x + player.width / 2 - 2 + totalOffset,
                        y: player.y,
                        width: 4,
                        height: 4,
                        speed: 10
                    };
                    bullets.push(bullet);
                }
            }
        }

        // Shoot cheat bullet
        function shootCheat() {
            const bullet = {
                x: player.x + player.width / 2 - 2,
                y: player.y,
                width: 4,
                height: 4,
                speed: 10
            };
            bullets.push(bullet);
        }

        // Collision detection
        function checkCollision(rect1, rect2) {
            return (rect1.x < rect2.x + rect2.width &&
                    rect1.x + rect1.width > rect2.x &&
                    rect1.y < rect2.y + rect2.height &&
                    rect1.y + rect1.height > rect2.y);
        }

        // Check if block should stop falling
        function checkBlockLanding(block) {
            const nextY = block.y + block.speed;
            if (nextY + block.height >= canvas.height) {
                block.stopped = true;
                block.y = (GRID_HEIGHT - block.shape.length) * GRID_SIZE;
                return true;
            }
            for (let otherBlock of blocks) {
                if (otherBlock !== block && otherBlock.stopped) {
                    const otherTop = otherBlock.y;
                    if (nextY + block.height > otherTop && 
                        block.x < otherBlock.x + otherBlock.width && 
                        block.x + block.width > otherBlock.x) {
                        block.stopped = true;
                        block.y = otherTop - block.height;
                        return true;
                    }
                }
            }
            return false;
        }

        // Check if blocks have stacked beyond the top
        function checkStackOverflow() {
            for (let block of blocks) {
                if (block.stopped && block.y < 0) {
                    return true;
                }
            }
            return false;
        }

        // Reset game state
        function resetGame() {
            // Hide the overlay just in case.
            document.getElementById('gameOverOverlay').style.display = 'none';

            // Store the finished score before resetting.
            let finishedScore = score;
            // Save old personal highscore.
            let oldPersonalHighscore = highScore;
            // Update personal best if beaten.
            if (finishedScore > highScore) {
                highScore = finishedScore;
                localStorage.setItem('highScore', highScore);
            }

            // Build congratulatory message(s).
            let message = "";
            if (finishedScore > oldPersonalHighscore) {
                message += "Congratulations new Personal highscore!";
            }
            if (finishedScore > (window.topPublicScore || 0)) {
                message += (message ? " " : "") + "Congratulations new Public highscore!";
            }
            document.getElementById('congratsMessage').innerText = message;

            // Reset game state...
            player = {
                x: 9 * GRID_SIZE,
                y: 27 * GRID_SIZE,
                width: 2 * GRID_SIZE,
                height: GRID_SIZE,
                moveCooldown: 0,
                moveDelay: 10
            };
            invaders = [];
            bullets = [];
            blocks = [];
            score = 0;
            gameOver = false;
            timeElapsed = 0;
            blockSpawnRate = 0.01;
            baseBlockSpeed = 1;
            updateScoreDisplay();
            attachSubmitScoreListener();
            console.log("Restarting game...");
            setTimeout(() => {
                console.log("Calling gameLoop (via requestAnimationFrame)");
                gameLoopRequestID = requestAnimationFrame(gameLoop);
            }, 300);
        }

        // Update score display
        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score} | High Score: ${highScore}`;
        }

        // Draw grid with a starry background effect
        function drawGrid() {
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#333';
            for (let x = 0; x <= canvas.width; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= canvas.height; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            ctx.fillStyle = '#FFF';
            for (let i = 0; i < 50; i++) {
                const starX = Math.random() * canvas.width;
                const starY = Math.random() * canvas.height;
                ctx.fillRect(starX, starY, 1, 1);
            }
        }

        // Draw player as a spaceship
        function drawPlayer(x, y, width, height) {
            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.moveTo(x + width / 2, y);
            ctx.lineTo(x, y + height);
            ctx.lineTo(x + width, y + height);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(x + width / 2 - 4, y + height / 4, 8, 4);
        }

        // Draw invaders with more detail
        function drawInvader(x, y, width, height) {
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(x, y + height / 4, width, height / 2);
            ctx.fillRect(x + width / 4, y, width / 2, height);
        }

        // New helper function â€“ returns false if the intended new position collides
        // with any blocks that have stopped (i.e. settled at the bottom)
        function canMove(newX, newY) {
            const newRect = { x: newX, y: newY, width: player.width, height: player.height };
            for (let i = 0; i < blocks.length; i++) {
                // Only consider blocks that are stopped (i.e. have landed)
                if (blocks[i].stopped && checkCollision(newRect, blocks[i])) {
                    return false;
                }
            }
            return true;
        }

        // Game loop
        function gameLoop(timestamp) {
            console.log("gameLoop running, gameOver =", gameOver);
            if (gameOver) {
                ctx.fillStyle = 'white';
                ctx.font = '40px Arial';
                ctx.fillText('Game Over', 100, 300);
                return;
            }

            timeElapsed += 1/60;
            blockSpawnRate = Math.min(0.05, 0.01 + timeElapsed * 0.0005);

            drawGrid();

            if (player.moveCooldown > 0) player.moveCooldown--;
            if (player.moveCooldown <= 0) {
                if (leftPressed && player.x > 0) {
                    let newX = player.x - GRID_SIZE;
                    if (canMove(newX, player.y)) {
                        player.x = newX;
                        player.moveCooldown = player.moveDelay;
                    }
                }
                if (rightPressed && player.x < canvas.width - player.width) {
                    let newX = player.x + GRID_SIZE;
                    if (canMove(newX, player.y)) {
                        player.x = newX;
                        player.moveCooldown = player.moveDelay;
                    }
                }
                if (upPressed && player.y > 0) {
                    let newY = player.y - GRID_SIZE;
                    if (canMove(player.x, newY)) {
                        player.y = newY;
                        player.moveCooldown = player.moveDelay;
                    }
                }
                if (downPressed && player.y < canvas.height - player.height) {
                    let newY = player.y + GRID_SIZE;
                    if (canMove(player.x, newY)) {
                        player.y = newY;
                        player.moveCooldown = player.moveDelay;
                    }
                }
            }
            if (cheatMode) {
                shootCheat();
            } else if (shootRequested) {
                shoot();
                shootRequested = false;
            }

            drawPlayer(player.x, player.y, player.width, player.height);

            bullets.forEach((bullet, bIndex) => {
                bullet.y -= bullet.speed;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, 2, 0, Math.PI * 2);
                ctx.fill();

                invaders.forEach((invader, iIndex) => {
                    if (checkCollision(bullet, invader)) {
                        invaders.splice(iIndex, 1);
                        bullets.splice(bIndex, 1);
                        score += 10;
                        updateScoreDisplay();
                    }
                });

                blocks.forEach((block, blIndex) => {
                    if (checkCollision(bullet, block)) {
                        blocks.splice(blIndex, 1);
                        bullets.splice(bIndex, 1);
                        score += 5;
                        updateScoreDisplay();
                    }
                });

                if (bullet.y < 0) bullets.splice(bIndex, 1);
            });

            invaders.forEach((invader, index) => {
                invader.y += invader.speed;
                drawInvader(invader.x, invader.y, invader.width, invader.height);

                if (!cheatMode && checkCollision(invader, player)) {
                    gameOver = true;
                }
            });

            blocks.forEach((block, index) => {
                if (!block.stopped) {
                    block.y += block.speed;
                    checkBlockLanding(block);
                }
                
                ctx.fillStyle = block.color;
                ctx.strokeStyle = '#000';
                for (let i = 0; i < block.shape.length; i++) {
                    for (let j = 0; j < block.shape[i].length; j++) {
                        if (block.shape[i][j]) {
                            ctx.fillRect(
                                block.x + j * GRID_SIZE,
                                block.y + i * GRID_SIZE,
                                GRID_SIZE - 2,
                                GRID_SIZE - 2
                            );
                            ctx.strokeRect(
                                block.x + j * GRID_SIZE,
                                block.y + i * GRID_SIZE,
                                GRID_SIZE - 2,
                                GRID_SIZE - 2
                            );
                        }
                    }
                }

                if (!cheatMode && !block.stopped && checkCollision(block, player)) {
                    gameOver = true;
                }
            });

            if (checkStackOverflow()) {
                gameOver = true;
            }

            // --- Alien Animations ---
            // At high scores, spawn alien animations â€“ more frequently after 1000 points.
            if (score >= 500 && Math.random() < 0.005) {
                spawnAlienAnimation();
            }
            if (score >= 1000 && Math.random() < 0.01) {
                spawnAlienAnimation();
            }

            // Update and draw active alien animations
            for (let i = alienAnims.length - 1; i >= 0; i--) {
                updateAlien(alienAnims[i]);
                drawAlien(alienAnims[i]);
                if (alienAnims[i].x > canvas.width || alienAnims[i].life <= 0) {
                    alienAnims.splice(i, 1);
                }
            }

            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000';
            ctx.font = '20px Arial';
            ctx.lineWidth = 2;
            ctx.strokeText(`Score: ${score}`, 10, 30);
            ctx.fillText(`Score: ${score}`, 10, 30);

            if (Math.random() < 0.02) spawnInvader();
            if (Math.random() < blockSpawnRate) spawnBlock();

            if (gameOver) {
                // Stop the loop by not requesting another frame and show the overlay.
                document.getElementById('gameOverOverlay').style.display = 'flex';
            } else {
                gameLoopRequestID = requestAnimationFrame(gameLoop);
            }
        }

        // Start game and handle restart
        updateScoreDisplay();
        restartBtn.addEventListener('click', resetGame);
        requestAnimationFrame(gameLoop);

        // Load Firebase asynchronously so that it doesn't block the game start.
        (async function loadFirebase() {
            const { initializeApp } = await import("https://www.gstatic.com/firebasejs/9.6.10/firebase-app.js");
            const { getAnalytics } = await import("https://www.gstatic.com/firebasejs/9.6.10/firebase-analytics.js");
            const {
                getDatabase, ref, push, set,
                query, onValue, orderByChild, limitToLast
            } = await import("https://www.gstatic.com/firebasejs/9.6.10/firebase-database.js");

            const firebaseConfig = {
              apiKey: "AIzaSyDv2Aow7VEUnFXglySeGG-EylH78UJVt7c",
              authDomain: "spacetris-cc8ec.firebaseapp.com",
              databaseURL: "https://spacetris-cc8ec-default-rtdb.europe-west1.firebasedatabase.app",
              projectId: "spacetris-cc8ec",
              storageBucket: "spacetris-cc8ec.firebasestorage.app",
              messagingSenderId: "866701367465",
              appId: "1:866701367465:web:e5d22916bb27355cbdf1b8",
              measurementId: "G-N8CXH11E8K"
            };
            const appFirebase = initializeApp(firebaseConfig);
            const analytics = getAnalytics(appFirebase);
            // Assign the database instance to a global variable.
            window.database = getDatabase(appFirebase);
            // Expose the Firebase functions on the global scope so they can be used in getPublicHighscores.
            window.ref = ref;
            window.push = push;
            window.set = set;
            window.query = query;
            window.onValue = onValue;
            window.orderByChild = orderByChild;
            window.limitToLast = limitToLast;

            // Now that Firebase is loaded, start listening for public highscores.
            getPublicHighscores();
        })();

        // Helper function to sanitize user input by escaping HTML characters.
        function sanitize(input) {
             return input.replace(/[&<>"'\/]/g, function(s) {
                 const entityMap = {
                     '&': '&amp;',
                     '<': '&lt;',
                     '>': '&gt;',
                     '"': '&quot;',
                     "'": '&#39;',
                     '/': '&#x2F;'
                 };
                 return entityMap[s];
             });

        function submitScore(score) {
            const nicknameInput = document.getElementById('nicknameInput');
            let name = nicknameInput.value.trim() || localStorage.getItem("playerName") || "Anonymous";
            // Sanitize the name to prevent XSS if someone submits malicious code.
            name = sanitize(name);
            // Save the sanitized player's name for future sessions.
            localStorage.setItem("playerName", name);
            // (Optional: add a fallback prompt if name is empty)
            const highscoresRef = ref(window.database, 'highscores');
            const newScoreRef = push(highscoresRef);
            set(newScoreRef, { name: name, score: score, timestamp: Date.now() });
        }

        // Update public highscores display in real-time
        function getPublicHighscores() {
            const highscoresQuery = query(ref(window.database, 'highscores'), orderByChild('score'), limitToLast(25));
            onValue(highscoresQuery, (snapshot) => {
                let scores = [];
                snapshot.forEach((childSnapshot) => {
                    scores.push(childSnapshot.val());
                });
                // Sort in descending order
                scores.sort((a, b) => b.score - a.score);
                // Store the current highest public score globally.
                if (scores.length > 0) {
                    window.topPublicScore = scores[0].score;
                } else {
                    window.topPublicScore = 0;
                }
                const publicHighscoreDisplay = document.getElementById('publicHighscoreDisplay');
                publicHighscoreDisplay.innerHTML = ''; // Clear any existing content
                const header = document.createElement('h3');
                header.textContent = 'Top 25 public scoreboard';
                publicHighscoreDisplay.appendChild(header);

                const list = document.createElement('ol');
                scores.forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = `${entry.name} - ${entry.score}`;
                    list.appendChild(li);
                });
                publicHighscoreDisplay.appendChild(list);
            });
        }

        // On load, pre-populate the nickname input with the stored name (if available)
        const storedName = localStorage.getItem("playerName");
        if (storedName) {
            document.getElementById('nicknameInput').value = storedName;
        }

        // Helper function to restore the Game Over overlay to its default state
        // and attach the submit score button event listener.
        function attachSubmitScoreListener() {
            const userProfile = document.getElementById('userProfile');
            // Restore the default content for the overlay safely.
            userProfile.innerHTML = '';  // Clear existing content
            const p = document.createElement('p');
            p.textContent = 'Game Over! Enter your nickname to submit your score:';
            userProfile.appendChild(p);

            const input = document.createElement('input');
            input.type = "text";
            input.id = "nicknameInput";
            input.placeholder = "Enter your nickname";
            userProfile.appendChild(input);

            const btn = document.createElement('button');
            btn.id = "submitScoreBtn";
            btn.textContent = "Submit Score";
            userProfile.appendChild(btn);

            // Pre-populate the nickname input if a name was stored.
            const storedName = localStorage.getItem("playerName");
            if (storedName) {
                document.getElementById('nicknameInput').value = storedName;
            }
            // Attach the event listener.
            document.getElementById('submitScoreBtn').addEventListener('click', (e) => {
                e.preventDefault();
                console.log("Submit button clicked, starting countdown...");
                // Disable to avoid multiple clicks.
                const btn = document.getElementById('submitScoreBtn');
                btn.disabled = true;

                // Retrieve player's name (from input or storage).
                const nicknameInput = document.getElementById('nicknameInput');
                let name = nicknameInput.value.trim() || localStorage.getItem("playerName") || "Anonymous";
                // Save the player's name.
                localStorage.setItem("playerName", name);
                console.log("Submitting score for:", name, "Score:", score);

                // Submit the score.
                submitScore(score);

                // Ensure the overlay is visible.
                const overlay = document.getElementById('gameOverOverlay');
                overlay.style.display = 'flex';

                // Replace the overlay content with a big countdown message.
                const cp = document.getElementById('userProfile');
                cp.textContent = '<div id="countdownMessage" style="font-size: 72px; font-weight: bold; color: #00FFFF;">3</div>';

                // Fixed countdown timing (total duration 1.5 seconds).
                setTimeout(() => {
                    document.getElementById('countdownMessage').textContent = "2";
                }, 375);
                setTimeout(() => {
                    document.getElementById('countdownMessage').textContent = "1";
                }, 750);
                setTimeout(() => {
                    document.getElementById('countdownMessage').textContent = "GO!";
                }, 1125);
                setTimeout(() => {
                    overlay.style.display = 'none';
                    btn.disabled = false;
                    resetGame();
                }, 1500);
            });
        }

        // Helper function to detect mobile devices.
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded. Showing mobile controls on all devices.");
            // Always show mobile controls, regardless of device
            document.getElementById('joystickContainer').style.display = 'block';
            document.getElementById('mobileFireBtn').style.display = 'block';

            console.log("Attaching submitScoreBtn listener via attachSubmitScoreListener().");
            attachSubmitScoreListener();
        });

        // Spawn a new alien animation object.
        function spawnAlienAnimation() {
            let alien = {
                // Start slightly off the left edge.
                x: -30,
                // Random vertical position within the canvas.
                y: Math.random() * (canvas.height - 30),
                // Horizontal velocity between 2 and 5 pixels per frame.
                vx: 2 + Math.random() * 3,
                vy: 0, // no vertical movement
                life: 300  // lasts for about 300 frames
            };
            alienAnims.push(alien);
        }

        // Update alien position and age.
        function updateAlien(alien) {
            alien.x += alien.vx;
            alien.y += alien.vy;
            alien.life--;
        }

        // Draw a simple 8-bit alien. You can adjust these drawing parameters for more flair.
        function drawAlien(alien) {
            ctx.fillStyle = '#00FF00';  // bright green alien body
            ctx.fillRect(alien.x, alien.y, 20, 20);  // alien's body
            ctx.fillStyle = '#000000';  // alien eyes
            ctx.fillRect(alien.x + 5, alien.y + 5, 4, 4);
            ctx.fillRect(alien.x + 11, alien.y + 5, 4, 4);
        }

        // Settings event listeners
        document.getElementById('settingsBtn').addEventListener('click', () => {
            pauseGame();
            // Preload current sensitivity and mute settings
            document.getElementById('keyboardSensitivitySlider').value = player.moveDelay;
            document.getElementById('muteMusicCheckbox').checked = isMuted;
            // Preload player's name from localStorage (or show "Anonymous")
            let storedName = localStorage.getItem("playerName") || "Anonymous";
            document.getElementById('playerNameDisplay').textContent = "Player: " + storedName;
            document.getElementById('settingsOverlay').style.display = 'flex';
        });

        document.getElementById('closeSettingsBtn').addEventListener('click', () => {
            // Retrieve updated settings values
            const slider = document.getElementById('keyboardSensitivitySlider');
            const muteCheckbox = document.getElementById('muteMusicCheckbox');

            // Update keyboard sensitivity (player moveDelay)
            player.moveDelay = parseInt(slider.value);

            // Update mute setting for the background music
            isMuted = muteCheckbox.checked;
            if (bgMusic) {
                bgMusic.muted = isMuted;
            }

            // Hide the settings overlay and resume game
            document.getElementById('settingsOverlay').style.display = 'none';
            resumeGame();
        });

        function pauseGame() {
            gamePaused = true;
            cancelAnimationFrame(gameLoopRequestID);
        }

        function resumeGame() {
            gamePaused = false;
            gameLoopRequestID = requestAnimationFrame(gameLoop);
        }

        // Update sensitivity value display and game parameter in real time.
        const sensitivitySlider = document.getElementById('keyboardSensitivitySlider');
        const sensitivityDisplay = document.getElementById('keyboardSensitivityValue');
        sensitivitySlider.addEventListener('input', () => {
            sensitivityDisplay.textContent = sensitivitySlider.value;
            // Lower moveDelay means faster movement. Use the slider value as moveDelay.
            player.moveDelay = parseInt(sensitivitySlider.value);
        });

        // Helper function to display a temporary "Now Playing" message.
        function displayNowPlaying(trackPath) {
             // Extract the file name (remove folder path) and strip ".mp3"
             let fileName = trackPath.split("/").pop();
             let albumName = fileName.replace(".mp3", "");
             let message = "Now Playing: " + albumName + " - Sebastien Bourgeois";
 
             let msgElem = document.getElementById("nowPlayingMessage");
             if (!msgElem) {
                 msgElem = document.createElement("div");
                 msgElem.id = "nowPlayingMessage";
                 msgElem.style.position = "fixed";
                 msgElem.style.top = "50px";
                 msgElem.style.left = "50%";
                 msgElem.style.transform = "translateX(-50%)";
                 msgElem.style.color = "white";
                 msgElem.style.fontFamily = "Arial, sans-serif";
                 msgElem.style.background = "rgba(0, 0, 0, 0.5)";
                 msgElem.style.padding = "5px 10px";
                 msgElem.style.borderRadius = "5px";
                 msgElem.style.zIndex = "2000";
                 document.body.appendChild(msgElem);
             }
 
             msgElem.textContent = message;
             msgElem.style.display = "block";
             setTimeout(() => {
                 msgElem.style.display = "none";
             }, 5000);
        }
    </script>
</body>
</html>
